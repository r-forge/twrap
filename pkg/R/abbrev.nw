Functions for making concise summaries for table cells
======================================================

Preface
-------

This is a `noweb` file that contains textual
documentation, R code chunks, and the function
documentation.  See the Appendix at bottom to
learn how to process it. 

Motivation
----------

A lot of an analysts time is spent creating tables. Often the entries
in the table cells are simple numeric summaries such as mean (SD) or
median (IQR). There are a number of functions here that calculate
these numeric summaries and provide format methods to display the
summaries in a concise or abbreviated way (e.g., as "mean (SD)" shown
to two decimal places).

Function list
-------------

1. `medIQR` provides the median and interquartile range

3. `medR` provides the median and range

2. `meanSD` provides the mean and SD

4. `tbl` provides counts and proportions

Next steps
----------
1. Make this program a little more literate with helpful 
   comments so I can remember what each piece does and how I do it

2. Format needs to handle digits somehow. Keep it simple and 
   do decimal places rather than significant digits.
   
3. Is there a nice algorithm for showing digits? Something like 
   how many digits distingish the quartiles? Another approach
   is to keep two digits in the residuals. 

4. P-values are needed.   
   
The print/format methods could allow either of:
                   Group
     Statistic      Active       Control
       Median (IQR) 3 (1 to 7)   5 (2 to 8)

or
   
                   Group
     Statistic      Active       Control
       Median       3            5
       IQR          1 to 7       2 to 8
       
or

                   Group
     Statistic      Active       Control
       Median       3            5
       IQR          1 to 7       2 to 8
       Range        0 to 11      1 to 15
     
       
Example data
------------

This is an example data set used throughout.

<<Rcode>>=
set.seed(944)
y <- rnorm(100)
g <- sample(letters[1:3], size = 100, replace = TRUE)
sex <- sample(c("M", "F"), size = 100, replace = TRUE)
dx <- sample(c("Active", "Control"), size = 100, replace = TRUE)
d <- data.frame(y = y, g = g, sex = sex, dx = dx)
@   

Generics
--------

First the generics. We create these because these should be able to
handle different classes of objects. We need a generic to do this.  I
don't fully understand generics, and specifically don't know when
to use `NextMethod` (so I don't).

<<Rcode>>=
medIQR <- function(x, ...) UseMethod("medIQR")
medR <-   function(x, ...) UseMethod("medR")
meanSD <- function(x, ...) UseMethod("meanSD")
tbl <-    function(x, ...) UseMethod("tbl")
@ 

Default method
--------------

Now that generics are set up, we define the defaults. I need error
checking here but am saving that for later. In some sense the
underlying univariate functions provide error checking.

<<Rcode>>=
medIQR.default <- function(x, na.rm = TRUE, ...) {
    qq <- stats::quantile(x, c(0.50, 0.25, 0.75), na.rm = na.rm, ...)
    structure(qq, 
              names = c("Median", "Q1", "Q3"),
              class = "medIQR") # how about EstInterval?
}

medR.default <- function(x, na.rm = TRUE) {
    m <- mean(x, na.rm = na.rm)
    r <- range(x, na.rm = na.rm)
    structure(c(m, r),
              names = c("Median", "Minimum", "Maximum"),
              class = "medR")
    
}

meanSD.default <- function(x, na.rm = TRUE) {
    m <- mean(x, na.rm = na.rm)
    s <- sd(x, na.rm = na.rm)
    structure(c(m, s),
              names = c("Mean", "SD"),
	      class = "meanSD")
}


tbl.default <- function(rowvar, ...) {
  counts <- base::table(rowvar, ...)
  percents <- prop.table(counts)
  m <- matrix(c(counts, percents), 
              byrow = FALSE, nrow = length(counts),
              dimnames = list(Level = names(counts),
                c("Number", "Percent")))
  structure(m,
            class = c("tbl", "matrix"))
}

@ 

Now the formula interfaces.

<<Rcode>>=
medIQR.formula <- function(formula,
                           data = NULL, ...,
                           subset, na.action = NULL,
                           overall = FALSE,
                           overall.label = "Overall") {
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$overall <- m$overall.label <- NULL
  m$na.action <- na.action
  require(stats, quietly = TRUE)
  m[[1]] <- as.name("model.frame")
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  s <- split(mf[[response]], mf[-response])
  
  if(overall) {
    if(any(names(s) == overall.label))
    stop(sQuote(overall.label), " is an existing level")
    s <- c(Overall = list(unlist(s)), s)
  }
  structure(sapply(s, FUN = medIQR, ...),
            class = "medIQR")
}



meanSD.formula <- function(formula,
                   data = NULL, ...,
                   subset, na.action = NULL,
	           overall = FALSE,
                   overall.label = "Overall") {
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$overall <- m$overall.label <- NULL
  m$na.action <- na.action
  require(stats, quietly = TRUE)
  m[[1]] <- as.name("model.frame")
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  s <- split(mf[[response]], mf[-response])
  
  if(overall) {
    if(any(names(s) == overall.label))
    stop(sQuote(overall.label), " is an existing level")
    s <- c(Overall = list(unlist(s)), s)
  }  
  structure(sapply(s, FUN = meanSD, ...),
            class = "meanSD")
}

medR.formula <- function(formula,
                 data = NULL, ...,
                 subset, na.action = NULL,
		 overall = FALSE,
                 overall.label = "Overall") {
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$overall <- m$overall.label <- NULL
  m$na.action <- na.action
  require(stats, quietly = TRUE)
  m[[1]] <- as.name("model.frame")
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  s <- split(mf[[response]], mf[-response])
  if(overall) {
    if(any(names(s) == overall.label))
    stop(sQuote(overall.label), " is an existing level")
    s <- c(Overall = list(unlist(s)), s)
  }  
  structure(sapply(s, FUN = medR, ...),
            class = "medR")
}


## This must be able to handle the cases where 
## the levels are not the same for each
## group
tbl.formula <- function(formula,
                 data = NULL, ...,
                 subset, na.action = NULL,
		 overall = FALSE,
                 overall.label = "Overall") {
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$overall <- m$overall.label <- NULL
  m$na.action <- na.action
  require(stats, quietly = TRUE)
  m[[1]] <- as.name("model.frame")
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  # assume groups are factors
  # but make the response a factor
  y <- mf[[response]]
  if(!inherits(y, "factor"))
    y <- factor(y)
  
  s <- split(y, mf[-response]) 
  if(overall) {
    if(any(names(s) == overall.label))
    stop(sQuote(overall.label), " is an existing level")
    s <- c(Overall = list(unlist(s)), s)
  }  
  structure(lapply(s, FUN = tbl, ...),
            class = "tbl")
}
@ 


Now some tests.
<<Rcode>>=
medIQR(rnorm(10))

m <- medIQR(y ~ g, data = d)
print(m)
class(m)
tbl(g ~ sex, data = d, overall = TRUE)
@ 

These are attempts at print and format methods.

<<Rcode>>=
## Must be able to handle vectors or matrices
## See format.data.frame
format.medIQR <- function(x, ...) {

  f <- function(y, ...) {
    yy <- sapply(y, formatC, format = "f", ...)
    names(yy) <- names(y)
    c("Median (IQR)" =
      paste(yy["Median"], " (", yy["Q1"], " to ", yy["Q3"], ")", 
            sep = "", collapse = ""))
  }
  
  if(!is.matrix(x))
    return(f(x, ...))
  dims <- dim(x)
  nr <- dims[1]
  nc <- dims[2]
  rval <- vector("list", nc)
  for (i in 1:nc) rval[[i]] <- f(x[, i], ...)
  
  ## return(unlist(rval))
  dn <- dimnames(x)  
  xx <- do.call("cbind", rval)
  dimnames(xx) <- list("Statistic" = "Median (IQR)",
                       "Group" = dn[[2]])
  xx
}

format.medIQR(medIQR(y))
format.medIQR(medIQR(y ~ g))
format.medIQR(medIQR(y ~ g, overall =T), digits = 2)

print.medIQR <- function(x, quote = FALSE, ...){
  print(format(x, ...), quote = quote)
  invisible(x)
}
@ 

Must be able to handle vectors or matrices
See `format.data.frame`.

<<Rcode>>=

format.tbl <- function(x, format = "f", digits = 1, omit.zero.pct = TRUE, ...) {

  f <- function(y, format = format, digits = digits, omit.zero.pct = TRUE, ...) {
     n <- y[, "Number"]
     p <- y[, "Percent"]
     p <- formatC(100 * p, format = format, digits = digits, ...)
     dn <- dimnames(y)
     m <- matrix(paste(n, " (", p, ")", sep = ""),
                 ncol = 1,
                 dimnames = list(Level = dn[[1]], "Number (%)"))
     if(omit.zero.pct) {
       m[n==0] <- "0"
     }  
     m
  }
  
  if(!is.list(x)) 
    return(f(x, ...))
  ##dims <- dim(x)
  ##nr <- dims[1]
  nc <- length(x)
  rval <- vector("list", nc)
  for (i in 1:nc) rval[[i]] <- f(x[[i]], ...)
  xx <- do.call("cbind", rval)
  dimnames(xx) <- list("No. (%) in each level" = row.names(x[[1]]),
                       "Group" = names(x))
  xx
}

print.tbl <- function(x, quote = FALSE, ...){
  print(format(x, ...), quote = quote)
  invisible(x)
}
print(tbl(sex))
print(tbl(sex ~ dx + g, data = d, overall = TRUE))
@

Some tests.

<<Rcode>>=

print(medIQR(y ~ g, data = d))
(medR(y ~ g, data = d))

medIQR(y ~ g)["Median", ]
medIQR(y ~ g)[,"a", drop = F]

print(medIQR(y ~ g, data = d))["Median", "b"] + 3 # WTF?

## toLatex.numeric <- function(x, ...) {
##   z <- ifelse(x < 0, paste("$ -", format(abs(x), ...), " $", sep = ""),
##               paste("$ ", format(x, ...), " $"))
##   class(z) <- "Latex"
##   z
## }
## toLatex(rnorm(3), digits = 2)

## toHTML.numeric <- function(x, ...) {
##   z <- ifelse(x < 0, paste("&#45;", format(abs(x), ...), sep = ""),
##               format(x, ...))
##   class(z) <- "HTML"
##   z
## }
## toHTML.numeric(medIQR(rnorm(10)))

@

Here I try to write the formula interfaces to include results from
hypothesis tests.

<<Rcode>>=
medIQR2.formula <- function(formula,
                            data = NULL, ...,
                            subset, na.action = NULL,
                            test = TRUE,
                            overall = FALSE,
                            overall.label = "Overall") {
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$overall <- m$overall.label <- NULL
  m$na.action <- na.action
  require(stats, quietly = TRUE)
  m[[1]] <- as.name("model.frame")
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  s <- split(mf[[response]], mf[-response])
  
  if(test) {
    DNAME <- paste(names(mf), collapse = " by ")
    DATA <- split(mf[[response]], g)
    names(DATA) <- c("x", "y")
    h <- do.call("wilcox.test", c(DATA, list(...)))
    h$data.name <- DNAME
  }
  
  
  if(overall) {
    if(any(names(s) == overall.label))
      stop(sQuote(overall.label), " is an existing level")
    s <- c(Overall = list(unlist(s)), s)
  }
  
  FIXME
  structure(list("statistic" = sapply(s, FUN = medIQR, ...),
                 "htest" = h),
            class = "medIQR")
}
@


Rounding
--------

I need an algorithm for rounding to an appropriate number of
(significant) digits. Things I can look at include `pretty`.

In terms of rounding percentages, the sample size gives
an indication of how many digits to show percentages to.
I think the AMA rule is show as many digits in the percentage
as are in the overall sample size. So n < 100 indicates
show to whole numbers. I would say n of 120 wouldn't merit
showing percentages to one decimal place, but maybe that's
just me.



Appendix
--------

To extract the R code chunks to form a complete 
function, type this at the shell:

     ~weigand/local/noweb/notangle -RRcode \
        filename.nw > filename.R

To extract the Rd chunks do

     ~weigand/local/noweb/notangle -RRd \
        filename.nw > filename.Rd

To read about Markdown syntax go [here][1].

You can possibly convert this document
to nicel formatted HTML with

     perl ~weigand/local/Markdown_1.0.1/Markdown.pl \
       --html4tags filename.nw > filename.html

I say "possibly" because I find the Markdown program
often chokes on what appears to be valid Markdown.
Despite this, the Markdown syntax makes a file 
very readable as is, so it's a nice way to
structure the docment. 

R code to extract the functions in this document is as follows.
<<Rcode>>=
s <- function() {
  notangle("abbrev.nw", 
           file.out = file.path(tempdir(), "noweb.R"),
           name = "Rcode")
  source(file.path(tempdir(), "noweb.R"), echo = TRUE)
}
@ 

A better approach which escaped me until now is just to use
`Stangle("abbrev.nw")`. 


[1]: http://daringfireball.net/projects/markdown/
